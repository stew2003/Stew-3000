# Microcode Documentation:

- **HLT**: Halt (when active this line stops the clock)
- **RST**: Reset (reset the step counter of the instruction)
- **PCE**: Program Counter Enable (program counter will increment on next clock pulse)
- **PCO**: Program Counter Out
- **PCI**: Program Counter In
- **MI**: Memory Address Register In
- **RO**: RAM Out
- **RI**: RAM In (write to RAM)
- **IO**: Instruction Register Out (never used)
- **II**: Instruction Register In
- **AO**: A-register Out
- **AI**: A-register In
- **BO**: B-register Out
- **BI**: B-register In
- **CO**: C-register Out
- **CI**: C-register In
- **TO**: Temp-register Out
- **TI**: Temp-register In
- **OI**: Output-register In (Decimal display)
- **LCS**: LCD Select (Data vs. Command)
- **LCE**: LCD Enable (Actively listening to bus)
- **EO**: ALU Out
- **EI**: ALU In
- **FI**: Flags-register In
- **NOT**: NOT ALU Operation
- **AND**: AND ALU Operation
- **XOR**: XOR ALU Operation
- **OR**: OR ALU Operation
- **SUM**: ADD ALU Operation
- **TS**: Select Temp-register as other operand or all 0s
- **CAR**: Set Carry/Borrow for addition and subtraction
- **SUB**: SUB ALU operation (add but with 1s compliment (2s compliment comes from setting CAR line))
- **PGM**: TODO: Accessing program or instruction memory
- **SO**: TODO: Stack pointer out
- **SI**: TODO: Stack pointer in

# Instruction Documentation:

- **ADD B**: Add the contents of B-register to contents of A-register, then save result in A-register
- **ADD C**: Add the contents of C-register to contents of A-register, then save result in A-register
- **ANA B**: AND the contents of B-register with contents of A-register, then save result in A-register
- **ANA C**: AND the contents of C-register with contents of A-register, then save result in A-register
- **ANI byte**: AND the byte operand with the A-register, then save the result in the A-register
- **DCR A**: Decrement the A-register by 1
- **DCR B**: Decrement the B-register by 1
- **DCR C**: Decrement the C-register by 1
- **HLT**: Halt the clock
- **INR A**: Increment the A-register by 1
- **INR B**: Increment the B-register by 1
- **INR C**: Increment the C-register by 1
- **JMP byte**: Jump to the location specified by the byte operand
- **LDA byte**: Load the A-register with the value at the RAM location specified by the byte operand
- **MOV A, B**: Move the contents of the A-register to the B-register
- **MOV A, C**: Move the contents of the A-register to the C-register
- **MOV B, A**: Move the contents of the B-register to the A-register
- **MOV B, C**: Move the contents of the B-register to the C-register
- **MOV C, A**: Move the contents of the C-register to the A-register
- **MOV C, B**: Move the contents of the C-register to the B-register
- **MVI A byte**: Move the byte operand into the A-register
- **MVI B byte**: Move the byte operand into the B-register
- **MVI C byte**: Move the byte operand into the C-register
- **NOP**: No operation, waste 8 clock cycles
- **ORA B**: OR the contents of B-register with contents of A-register, then save result in A-register
- **ORA C**: OR the contents of C-register with contents of A-register, then save result in A-register
- **ORI byte**: OR the contents of the A-register with the byte operand, then save the result in the A-register
- **OUT**: Load the contents of the A-register into the decimal display
- **STA byte**: Store the contents of the A-register into the location specified by the byte operand
- **SUB B**: Subtract the B-register from the A-register, then save the result in the A-register
- **SUB C**: Subtract the C-register from the A-register, then save the result in the A-register
- **XRA B**: XOR the contents of the A-register with the contents of the B-register, then save the result in the A-register
- **XRA C**: XOR the contents of the A-register with the contents of the C-register, then save the result in the A-register
- **XRI byte**: XOR the contents of the A-register with the byte operand, then save the result in the A-register
- **NOT A**: Save the compliment of the A-register in the A-register
- **NOT B**: Save the compliment of the B-register in the B-register
- **NOT C**: Save the compliment of the C-register in teh C-register
- **DIC byte**: Send the byte operand as a command to the LCD display
- **DID byte**: Send the byte operand as data to the LCD display
- **JC byte**: Jump to the address of the byte operand if the carry flag is set
- **JNC byte**: Jump to the address of the byte operand if the carry flag is not set
- **JZ byte**: Jump to the address of the byte operand if the zero flag is set
- **JNZ byte**: Jump to the address of the byte operand if the zero flag is not set

# Dream Instruction Set:

- **ADD $r1, $r2**: $r1 = $r1 + $r2
  - **ADD A, A**
  - **ADD A, B**
  - **ADD A, C**
  - **ADD B, A**
  - **ADD B, B**
  - **ADD B, C**
  - **ADD C, A**
  - **ADD C, B**
  - **ADD C, C**
  - **ADD SP, A**
  - **ADD SP, B**
  - **ADD SP, C**
- **ADDI $r1, byte**: $r1 = $r1 + byte
  - **ADDI A, byte**
  - **ADDI B, byte**
  - **ADDI C, byte**
  - **ADDI SP, byte**
- **SUB $r1, $r2**: $r1 = $r1 - $r2
  - **SUB A, B**
  - **SUB A, C**
  - **SUB B, A**
  - **SUB B, C**
  - **SUB C, A**
  - **SUB C, B**
  - **SUB SP, A**
  - **SUB SP, B**
  - **SUB SP, C**
- **SUBI $r1, byte**: $r1 = $r1 - byte
  - **SUBI A, byte**
  - **SUBI B, byte**
  - **SUBI C, byte**
  - **SUBI SP, byte**
- **AND $r1, $r2**: $r1 = $r1 & $r2
  - **AND A, B**
  - **AND A, C**
  - **AND B, A**
  - **AND B, C**
  - **AND C, A**
  - **AND C, B**
- **ANI $r1, byte**: $r1 = $r1 & byte
  - **ANI A, byte**
  - **ANI B, byte**
  - **ANI C, byte**
- **OR $r1, $r2**: $r1 = $r1 | $r2
  - **OR A, B**
  - **OR A, C**
  - **OR B, A**
  - **OR B, C**
  - **OR C, A**
  - **OR C, B**
- **ORI $r1, byte**: $r1 = $r1 | byte
  - **ORI A, byte**
  - **ORI B, byte**
  - **ORI C, byte**
- **XOR $r1, $r2**: $r1 = $r1 ^ $r2
  - **XOR A, B**
  - **XOR A, C**
  - **XOR B, A**
  - **XOR B, C**
  - **XOR C, A**
  - **XOR C, B**
- **XRI $r1, byte**: $r1 = $r1 ^ byte
  - **XRI A, byte**
  - **XRI B, byte**
  - **XRI C, byte**
- **NOT $r1**: $r1 = ~$r1
  - **NOT A**
  - **NOT B**
  - **NOT C**
- **INR $r1**: $r1 = $r1 + 1
  - **INR A**
  - **INR B**
  - **INR C**
  - **INR SP**
- **DCR $r1**: $r1 = $r1 - 1
  - **DCR A**
  - **DCR B**
  - **DCR C**
  - **DCR SP**
- **MOV $r1, $r2**: $r2 = $r1
  - **MOV A, B**
  - **MOV A, C**
  - **MOV B, A**
  - **MOV B, C**
  - **MOV C, A**
  - **MOV C, B**
- **LDI $r1, byte**: $r1 = byte
  - **LDI A, byte**
  - **LDI B, byte**
  - **LDI C, byte**
- **LDB $r1, $r2**: $r1 = RAM[$r2]
  - **LDB A, A**
  - **LDB A, B**
  - **LDB A, C**
  - **LDB B, A**
  - **LDB B, B**
  - **LDB B, C**
  - **LDB C, A**
  - **LDB C, B**
  - **LDB C, C**
- **STI $r1, byte**: RAM[byte] = $r1
  - **STI A, byte**
  - **STI B, byte**
  - **STI C, byte**
- **STB $r1, $r2**: RAM[$r2] = $r1
  - **STB A, A**
  - **STB A, B**
  - **STB A, C**
  - **STB B, A**
  - **STB B, B**
  - **STB B, C**
  - **STB C, A**
  - **STB C, B**
  - **STB C, C**
- **LDS $r1, byte**: $r1 = RAM[SP + byte]
  - **LDS A, byte**
  - **LDS B, byte**
  - **LDS C, byte**
- **STS $r1, byte**: RAM[SP + byte] = $r1
  - **STS A, byte**
  - **STS B, byte**
  - **STS C, byte**
- **CMP $r1, $r2**: $r1 - $r2 and set flags
  - **CMP A, B**
  - **CMP A, C**
  - **CMP B, A**
  - **CMP B, C**
  - **CMP C, A**
  - **CMP C, B**
- **JMP byte**: PC = byte
- **JMP $r1**: PC = $r1
  - **JMP A**
  - **JMP B**
  - **JMP C**
- **JE/JZ byte**: ZF ? PC = byte
- **JNE/JNZ byte**: ~ZF ? PC = byte
- **JG/JNLE byte**: ~(SF ^ OF) & ~ZF ? PC = byte
- **JGE/JNL byte**: ~(SF ^ OF) ? PC = byte
- **JL/JNGE byte**: SF ^ OF ? PC = byte
- **JLE/JNG byte**: (SF ^ OF) | ZF ? PC = byte
- **CALL byte**: SP += 1, Stack[SP] = PC, PC = byte
- **RET**: PC = Stack[SP], SP -= 1
- **DIC byte**: LCD command byte
- **DID byte**: LCD data byte
- **HLT**: Halt
- **NOP**: No operation
